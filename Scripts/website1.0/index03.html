<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>REEP</title>
    <link rel = "stylesheet" type = "text/css" href = "main.css"/>
</head>
<body>



    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script> <!-- from js folder, not jsm -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>
    
    <script>
 
        var scene, camera, renderer, raycaster;
        var geometry, material;
        var controls;
        var mouse;
        var state, substate;

        function init()
        {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xdddddd);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            raycaster = new THREE.Raycaster(); //Raycaster tracks the loacation of the cursor and which object reacts to the event
            renderer = new THREE.WebGLRenderer({antialias: true});
            mouse = new THREE.Vector2();
           
            renderer.setClearColor("#e5e8e5");
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);           
            camera.position.set(0, 0, 30);
            
            //adjust canvas size when resizing the window
            window.addEventListener('resize', ()=>
            {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            })

            light = new THREE.PointLight(0xFFFFFF, 1, 500);
            light.position.set(10, 0, -25);
            //scene.add(light);

            light_1 = new THREE.PointLight(0xFFFFFF, 1, 500);
            light_1.position.set(10, 0, 25);
            scene.add(light_1);

            state = 0;
            substate = 0;
        }
        function animate()
        {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        function Geometry_setup()
        {
            sphere_geometry = new THREE.SphereGeometry(1, 100, 100);
            sphere_material = new THREE.MeshLambertMaterial({color: 0xededed});
            centroid = new THREE.Vector3(0, 0, 0);

            pos = new Array(6);
            for (let i = 0; i < 6; i++)
            {
                pos[i] = new THREE.Vector3(0, 0, 0);
            }

            //-----------------------Instantitaion--------------------------

            mesh_sun = new THREE.Mesh(sphere_geometry, sphere_material);
            mesh_sun.scale.set(3, 3 ,3);
            mesh_sun.position.set(0, 0, 0);
            scene.add(mesh_sun);

            mesh_primary = new Array(6); 
            for (let i = 0; i < 6; i++)
            {
                mesh_primary[i] = new THREE.Mesh(sphere_geometry, sphere_material);
            }

            tl_secondary = new Array();
            for (let i = 0; i < 8; i++)
            {
                tl_secondary[i] = new THREE.Mesh(sphere_geometry, sphere_material); 
            }

            //-------------------------Resizing--------------------------------

            mesh_primary[0].scale.set(0.7, 0.7, 0.7);
            mesh_primary[1].scale.set(0.4, 0.4, 0.4);
            mesh_primary[2].scale.set(0.5, 0.5, 0.5);
            mesh_primary[3].scale.set(0.4, 0.4, 0.4);
            mesh_primary[4].scale.set(0.6, 0.6, 0.6);
            mesh_primary[5].scale.set(0.6, 0.6, 0.6);

            for (let k = 0; k < 8; k++)
            {
                tl_secondary[k].scale.set(0.6, 0.6, 0.6);
            }

            //-----------------------Euler Rotation---------------------------
            rot = new Array(6);
            rot[0] = new THREE.Euler(0, 30*Math.PI/180, 5*Math.PI/180, 'XYZ');
            rot[1] = new THREE.Euler(20*Math.PI/180, 0, -110*Math.PI/180, 'XYZ');
            rot[2] = new THREE.Euler(-40*Math.PI/180, -5*Math.PI/180, 120*Math.PI/180, 'XYZ');
            rot[3] = new THREE.Euler(-80*Math.PI/180, 40*Math.PI/180, -60*Math.PI/180, 'XYZ');
            rot[4] = new THREE.Euler(30*Math.PI/180, 0, 80*Math.PI/180, 'XYZ');
            rot[5] = new THREE.Euler(0, -130*Math.PI/180, 0, 'XYZ');
            
            //------------------------Positioning--------------------------------

            for (let i = 0; i < 6; i++)
            {
                pos[i].add(new THREE.Vector3(3, 0, 0));
                pos[i].applyEuler(rot[i]);
                pos[i].multiplyScalar(0.6);
                mesh_primary[i].position.copy(pos[i])
            }

            for (let i = 0; i < 8; i++)
            {
                mesh_primary[0].add(tl_secondary[i]);
            }

            tl_pos = new Array(8);
            tl_rot = new Array(8);

            for(let i = 0; i < 8; i++)
            {
                tl_pos[i] = new THREE.Vector3(3, 0, 0);
            }
            
            angle = -4*Math.PI/9;
            for (let i = 0; i < 8; i++)
            {
                tl_rot[i] = new THREE.Euler(rot[0].x, rot[0].y, rot[0].z + angle, 'XYZ');
                tl_pos[i].applyEuler(tl_rot[i]);
                tl_pos[i].multiplyScalar(0.01);
                tl_secondary[i].position.copy(tl_pos[i]);
                angle += Math.PI/9;
            }
           
            
            console.log(tl_secondary[0].position);
            console.log(tl_secondary[1].position);


            //----------------------------Adding to scene------------------------            

            for(let i = 0; i< 6; i++)
            {
                mesh_sun.add(mesh_primary[i]);
            }

            //----------------------------Naming---------------------------------

            mesh_sun.name = 'sun';

            for (let i = 0; i< 6; i++)
            {
                mesh_primary[i].name = i; 
            }
     
        }
       
        function OnMouseClick(event)
        {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(scene.children, true);//returns array of object that mouse in intersecting with
            for(i = 0; i < intersects.length; i++)
            {
                tl = new TimelineMax();
                tl.timeScale(1);

                switch(state)
                {
                    case 0:
                    if(intersects[i].object.name == 'sun')
                    {
                        switch(substate)
                        {
                            case 0:
                                substate = 1;
                                break;
                            case 1: 
                                substate = 0;
                                break;
                        } 
                        FSM_Update(state, substate);
                    }
                    if(substate == 1)
                    {
                        if(intersects[i].object.name == '0')
                        {
                            state = 1;
                            FSM_Update(state, substate);
                        }
                    }
                    break;
                }
                
                

                console.log(intersects[i].object.name);
            }
        }

        function FSM_Controller()
        {
            document.body.addEventListener('click', OnMouseClick);
           
        }
        function FSM_Update(zone, subzone)
        {
            switch(zone)
            {
                case 0:
                    switch(subzone)
                    {
                        case 0:
                            Primary_pos(1, -1);
                            break;
                        case 1:
                            Primary_pos(1.5, -1);
                            break;
                    }
                break;
                case 1:
                        Primary_pos(1, 0);
                        //mesh_sun.position.copy(new THREE.Vector3(0, 0, 0));
                        this.tl.to(mesh_sun.position, 0.5, {x: (-10),
                                                           y: (0), 
                                                           z: (-5),
                                                           ease: Elastic.easeOut.config(3, 3)
                                                            });

                        this.tl.to(mesh_primary[0].position, 0.5, {x: (pos[0].x*3),
                                                                   y: (pos[0].y*3), 
                                                                   z: (pos[0].z*3),
                                                                   ease: Elastic.easeOut.config(3, 3)
                                                                   });

                break;
            }
            
        }
        function Primary_pos(scalar, orb)
        {
            for (let j = 0; j < 6; j++)
            {
                if (j == orb) j++;
                this.tl.to(mesh_primary[j].position, 0.5, {x: (pos[j].x*scalar),
                                                            y: (pos[j].y*scalar), 
                                                            z: (pos[j].z*scalar),
                                                            ease: Elastic.easeOut.config(3, 3)
                                                            });
            }
}
        
        
        init();
        animate();
        Geometry_setup();
        FSM_Controller();

        
    </script>
</body>
</html>